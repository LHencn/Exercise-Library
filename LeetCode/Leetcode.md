# 1

## 暴力枚举

```c
int* twoSum(int* nums, int numsSize, int target) {
    static int res[2] = {0}; //静态数组延长数组的生命周期
    for (int i = 0; i < numsSize; i++) {
        int a = nums[i];
        for (int j = i + 1; j < numsSize; j++) {
            if (a + nums[j] == target) {
                res[0] = i;
                res[1] = j;
                
            }
        }
    }
    return res;
}
```

注：因为如果不用静态的话，数组的生命周期就是从定义的地方到函数结束，函数运行结束，这个内存也就释放掉了。返回的是数组的首地址，一旦函数运行结束，这个地址里的东西就变成空了，所以要用静态数组延长数组的生命周期。

## 两遍哈希表

方法：哈希表正是为此目的而构建的，它支持以 *近似* 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。

一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！

```c

```





